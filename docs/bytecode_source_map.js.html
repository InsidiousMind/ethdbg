<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: bytecode_source_map.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: bytecode_source_map.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const fs = require('fs');
const solc = require('solc');

/**
 * @author Sean Batzel
 *
 * A struct class used for associating source code lines with
 * the corresponding instructions in the bytecode.
 */
class LineMapping {
  constructor(line_number, source_line, byte_line, is_breakpoint) {
    /**
     * TODO figure out some way to keep track of jumps...
     */
    this.source_line = source_line;
    this.byte_line = byte_line;
    this.is_breakpoint = is_breakpoint;
    this.line_number = line_number;
  }
}

/**
 * @author Sean Batzel
 *
 * A class of functions for constructing the mapping of source
 * code to bytecode.
 */
class BytecodeSourceMap {
  /*
   * Source mappings end up in the following format:
   * 's:l:f:j;'
   *
   * s - source offset
   * l - section length
   * f - source index?
   * j - i if function, o if return, - if just jump
   *
   */

  /**
   * @author Sean Batzel
   * @author Andrew Plaza
   *
   * @param{source_code} source code in utf8
   * @param{contract_name} name of contract to debug
   */
  constructor(source_code, contract_name) {
    // Match up the source code, byte code, and source map line by line.
    this.source = source_code;
    this.compiled_source = solc.compile(source_code, 1);
    this.byte_c = this.compiled_source.contracts[`:${contract_name}`].bytecode;
    /// the mapping from bytecode to sourcecode
    this.srcmap_bin = this.compiled_source.contracts[`:${contract_name}`].srcmapRuntime;

    // This line should split the source map file in to an array of 
    // individual maps.
    let source_strings = this.source.split("\n");
    let byte_set = this.byte_c.split('');
    let source_maps = this.srcmap_bin.split(";");
    this.line_mapping_set = new Array();
    for (let i = 0; i &lt; byte_set.length; i++) {
      // TODO: line_match expects beginning and end of range:w
      let line_number = this.line_match(this.srcmap_bin[i]);
      let line = this.source[line_number];
      let byte_line = byte_set[i];
      this.line_mapping_set[new LineMapping(line_number, line, byte_line, false)];
    }
  }

  /**
   * @author Sean Batzel
   *
   * Given the byte range (source_map[1..2]), determine the line we're in.
   * Referenced by the line_match function in order to pull line numbers
   * out of the given range of bytes of source code.
   *
   * NOTE: If I'm thinking correctly, this should return the line number
   * we want. 
   *
   * WRITTEN RUBBER DUCK READY HERE WE GO:
   * The sum is the current length of the source code in bytes. We iterate
   * over the entire set of lines of source code, and if the initial byte
   * isn't in that line (i.e. the length of the source code we've checked
   * isn't longer than the byte we're looking for) we just add to the sum
   * and keep going. Otherwise, we're there! Good going! Return the line
   * number, bob's your uncle, get out of this function.
   *
   * @param{source} the set of all lines of source
   * @param{map_0} the beginning of a source code byte range.
   * @param{map_1} the end of a source code range.
   */
  line_by_byte(map_0, map_1) { 
    let sum = 0;
    for (let i = 0; i &lt; source.length; i++) {
      if ((sum + source[i].length) > map_0) {
        return i;
      } else {
        sum = sum + source[i].length;
      }
    }
  }

  /**
   * @author Sean Batzel
   * Return the set of the source line and starting/ending bytecode range.
   * This is the only use of the line_by_byte function.
   * @param{source_map} a particular source mapping set.
   */
  line_match(source_map) {
    let initial = source_map.split(":"); // produces the set { beginning, length, index, jump}
    // Based on initial[0], determine the line we're worried about
    let line_number = this.line_by_byte(source_code, initial[0], initial[1]);
    return line_number;
  }

  /**
   * This should return the LineMapping object so that we can easily pull source code, line numbers,
   * presence of a breakpoint, et cetera.
   */
  current_line() {
    // Get the source code range the current set of instructions covers
    // Determine line number.
    return line_mapping_set.pop();
  }

  /**
   * This will essentially be the same thing as current_line, only we want a way to pull the next
   * line without having to fiddle with indexing of LineMapping objects.
   */
  next_line() {
    // Get the source code range for the next line.
    // Determine the line number.
    return line_mapping_set.pop();
  }
}

module.exports = SourceMap;

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AsmSourceMap.html">AsmSourceMap</a></li><li><a href="BytecodeSourceMap.html">BytecodeSourceMap</a></li><li><a href="Debugger.html">Debugger</a></li><li><a href="Fork.html">Fork</a></li><li><a href="LineMapping.html">LineMapping</a></li><li><a href="Logger.html">Logger</a></li><li><a href="module.exports.html">exports</a></li><li><a href="TestRPC.html">TestRPC</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clc">clc</a></li><li><a href="global.html#Contract">Contract</a></li><li><a href="global.html#solc">solc</a></li><li><a href="global.html#SourceMappingDecoder">SourceMappingDecoder</a></li><li><a href="global.html#testRpc">testRpc</a></li><li><a href="global.html#URL">URL</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Nov 19 2017 19:01:53 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
