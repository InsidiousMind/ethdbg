<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: forkc.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: forkc.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>#! /usr/bin/env node

/**
 *@author Andrew Plaza &lt;aplaza@liquidthink.net>
 */
const URL = require('url');
const Web3 = require('web3');
const web3 = new Web3();
const {
  EventEmitter,
} = require('events');
const _ = require('lodash');
const ForkOptions = require('./types.js').fork_options;
const Ganache = require('../ganache-core/index.js');

/**
 * Some code taken from ethereumjs/testrpc
 *
 * Forks a running TestRPC + blockchain. Used for access to underlying EVM
 */
class Fork {
  /**
   *@param{Object} options - options to pass to testRPC
   *@param{Logger} logger - logger class
   */
  constructor(options, logger) {
    this.options = {};
    _.assignIn(this.options, ForkOptions, options);
    this.fork_address = null;
    this.server = null;
    this.state = null;
    this.ethdbg = new EventEmitter();
    this.logger = logger;
  }

  /**
   * Starts a server and begins to listen
   */
  init() {
    this.parseAddress();
    try {
      this.server = Ganache.server(this.options);
    } catch (err) {
      throw new Error('Error in initializing ganache server', err);
    }

    this.server.listen(
      this.options.port,
      this.options.hostname,
      this.listen.bind(this));
  }

  /**
   * We don't want to start a server with the same port as an already-running
   * server. parseAddress makes sure we don't
   */
  parseAddress() {
    let split = this.options.fork.split('@');
    this.fork_address = split[0];
    let block;
    if (split.length > 1) {
      block = split[1];
    }

    if (URL.parse(this.fork_address).port == this.options.port) {
      this.options.port = (parseInt(this.options.port) + 1);
    }
    this.options.fork = this.fork_address + (block != null ? '@' + block : '');
  }

  /**
   * The callback function passed to Ganache's server.listen()
   * @param{string} err - Error
   * @param{Object} result - Result returned from server
   */
  listen(err, result) {
    if (err) {
      throw new Error('Error in listening to ganache server', err);
    }

    this.state = result ? result : this.server.provider.manager.state;

    // add our events to the ethereumJS EVM object
    let newEVM = Object.assign(this.state.blockchain.vm, {
      __ethdbg: this.ethdbg,
    });
    this.state.blockchain.vm = newEVM;

    this.initServerEvents();
    if (this.options.fork) this.printForkMessage();

    // begin informing parent of ready state (first step)
    process.send(1);
    let address =
      (this.options.hostname || 'localhost') +
      ':' +
      this.options.port;
    process.send(`http://${address}`);
    this.logger.debug(`Listening on ${address}`);
  }

  /** listen for Ethereum Virtual Machine or ethdbg events */
  initServerEvents() {
    this.state.blockchain.vm.on('step', (eventObj) => {
      this.logger.debug(`Executed ${eventObj.opcode.name} \
      instruction in fork.js`);
    });

    process.on('message', (msg) => {
      // when we get back a 1, send ready event
      if (msg === 1) {
        process.send('ready');
      }
    });
  }

  /** prints the logger fork message */
  printForkMessage() {
    this.logger.debug('');
    this.logger.debug('Forked Chain');
    this.logger.debug('==================');
    this.logger.debug('Location:    ' + this.fork_address);
    this.logger.debug('Block:       ' + web3.toBigNumber(this.state
      .blockchain
      .fork_block_number).toString(10));
    this.logger.debug('Network ID:  ' + this.state.net_version);
    this.logger.debug('Time:        ' + (this.state
        .blockchain
        .startTime || new Date())
      .toString());
    this.logger.debug('');
  }
}


module.exports = Fork;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AsmSourceMap.html">AsmSourceMap</a></li><li><a href="BytecodeSourceMap.html">BytecodeSourceMap</a></li><li><a href="Debugger.html">Debugger</a></li><li><a href="Fork.html">Fork</a></li><li><a href="LineMapping.html">LineMapping</a></li><li><a href="Logger.html">Logger</a></li><li><a href="module.exports.html">exports</a></li><li><a href="TestRPC.html">TestRPC</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clc">clc</a></li><li><a href="global.html#Contract">Contract</a></li><li><a href="global.html#solc">solc</a></li><li><a href="global.html#SourceMappingDecoder">SourceMappingDecoder</a></li><li><a href="global.html#testRpc">testRpc</a></li><li><a href="global.html#URL">URL</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Nov 19 2017 19:01:53 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
